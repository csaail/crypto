


































































#!pip install bcrypt
# Salt and Hash

import bcrypt

# Get user password and prepare fake password for comparison
pwd = input('Enter the Password: ')
falsepwd = 'FalsePassword'

# Encode the passwords to bytes
bytepwd = pwd.encode('UTF-8')
bytefpwd = falsepwd.encode('UTF-8')

# Generate Salt
mySalt = bcrypt.gensalt()

# Hash the password
hash_val = bcrypt.hashpw(bytepwd, mySalt)
print('Hashed password:', hash_val)

# Check if entered password matches the hash
print('Matching hashed password with entered password:', bcrypt.checkpw(bytepwd, hash_val))
print('Matching hashed password with false password:', bcrypt.checkpw(bytefpwd, hash_val))


=========================================================================================================================================================================



# P2 Shift Cipher / Caeser Cipher

# Encryption function
def encrypt_words(plain_text, key):
    cipher_text = ''
    for word in plain_text:
        for i in word:
            if i.isupper():
                val = ord(i) - 65
                enc_word = chr(65 + (val + key) % 26)
            else:
                val = ord(i) - 97
                enc_word = chr(97 + (val + key) % 26)
            cipher_text += enc_word
    print('Encrypted Text:', cipher_text)
    return cipher_text

# Decryption function
def decrypt_words(cipher_text, key):
    plain_text = ''
    for word in cipher_text:
        for i in word:
            if i.isupper():
                val = ord(i) - 65
                dec_word = chr(65 + (val - key) % 26)
            else:
                val = ord(i) - 97
                dec_word = chr(97 + (val - key) % 26)
            plain_text += dec_word
    print('Decrypted Text:', plain_text)

# Main program
plain_text = input('Enter the plain text to be encrypted & decrypted: ').split()
key = int(input('Enter the key for Shift Cipher: '))

cipher_text = encrypt_words(plain_text, key)
decrypt_words(cipher_text, key)






=========================================================================================================================================================================



#P2B Vigenere Cipher

import numpy as np

# Encryption
def encrypt_words(plain_text, key):
    cipher_text = ''
    n = len(plain_text)
    ceil_val = int(np.math.ceil(n / len(key)))
    key = (key * ceil_val)[:n]

    for i in range(n):
        if plain_text[i].isupper():
            pi = ord(plain_text[i]) - 65
            ki = ord(key[i]) - 65
            ei = (pi + ki) % 26
            cipher_text += chr(65 + ei)
        else:
            pi = ord(plain_text[i]) - 97
            ki = ord(key[i]) - 97
            ei = (pi + ki) % 26
            cipher_text += chr(97 + ei)

    print('Encrypted Text:', cipher_text)
    return cipher_text

# Decryption
def decrypt_words(cipher_text, key):
    plain_text = ''
    n = len(cipher_text)
    ceil_val = int(np.math.ceil(n / len(key)))
    key = (key * ceil_val)[:n]

    for i in range(n):
        if cipher_text[i].isupper():
            ei = ord(cipher_text[i]) - 65
            ki = ord(key[i]) - 65
            di = (ei - ki)
            if di >= 0:
                di = di % 26
            else:
                di = (di + 26) % 26
            plain_text += chr(65 + di)
        else:
            ei = ord(cipher_text[i]) - 97
            ki = ord(key[i]) - 97
            di = (ei - ki)
            if di >= 0:
                di = di % 26
            else:
                di = (di + 26) % 26
            plain_text += chr(97 + di)

    print('Decrypted Text:', plain_text)


# Main
plain_text = input('Enter the plain text to be encrypted and decrypted: ')
key = input('Enter the key for Vigenere cipher: ')
cipher_text = encrypt_words(plain_text, key)
decrypt_words(cipher_text, key)


=========================================================================================================================================================================


#P2C Affine Cipher

# Affine Cipher Encryption
def encrypt_words(plain_text, a, b):
    cipher_text = ''
    for word in plain_text:
        for i in word:
            if i.isupper():
                val = ord(i) - 65
                cal = ((a * val) + b) % 26
                enc_word = chr(65 + cal)
            else:
                val = ord(i) - 97
                cal = ((a * val) + b) % 26
                enc_word = chr(97 + cal)
            cipher_text += enc_word
    print('Encrypted Text:', cipher_text)
    return cipher_text

# Affine Cipher Decryption
def decrypt_words(cipher_text, a, b):
    plain_text = ''

    # Find modular inverse of a under mod 26
    c = 0
    for i in range(1, 27):
        if (a * i) % 26 == 1:
            c = i
            break

    for word in cipher_text:
        for i in word:
            if i.isupper():
                val = ord(i) - 65
                cal = (c * (val - b)) % 26
                dec_word = chr(65 + cal)
            else:
                val = ord(i) - 97
                cal = (c * (val - b)) % 26
                dec_word = chr(97 + cal)
            plain_text += dec_word
    print('Decrypted Text:', plain_text)

# Main
plain_text = input('Enter the plain text to be encrypted & decrypted: ').split()
a = int(input('Enter the key for a: '))
b = int(input('Enter the key for b: '))

cipher_text = encrypt_words(plain_text, a, b)
decrypt_words(cipher_text, a, b)


=========================================================================================================================================================================

#P3 Cryotoanalysis

def cryptanalysis():
    cipher_text = input('Enter the cipher text for cryptanalysis: ')

    for k in range(26):  # Try all possible shift values
        plain_text = ''
        for letter in cipher_text:
            if letter == ' ':
                plain_text += letter
            else:
                c = ord(letter) - 65  # Convert to 0â€“25 range
                e = (c - k) % 26
                plain_text += chr(e + 65)
        print(f'With key = {k}, Decrypted Text: {plain_text}')

# Run the function
cryptanalysis()

=========================================================================================================================================================================


#!pip install pycryptodome
#P4 AES

from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

def encrypt_file(input_file, output_file, key):

    with open(input_file, 'rb') as f:
        data = f.read()
    cipher = AES.new(key, AES.MODE_CBC)
    encrypted = cipher.encrypt(pad(data, AES.block_size))
    with open(output_file, 'wb') as f:
        f.write(cipher.iv + encrypted)

def decrypt_file(input_file, output_file, key):

    with open(input_file, 'rb') as f:
        iv = f.read(16)
        encrypted = f.read()
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decrypted = unpad(cipher.decrypt(encrypted), AES.block_size)
    with open(output_file, 'wb') as f:
        f.write(decrypted)

def main():
    # Generate a random 16-byte (128-bit) AES key
    key = get_random_bytes(16)

    input_file = input("Enter the path of the input file to encrypt/decrypt: ").strip()

    encrypt_file(input_file, 'encrypt.txt', key)
    print(f"File encrypted ")

    decrypt_file('encrypt.txt', 'decrypt.txt', key)
    print(f"File decrypted ")

if __name__ == "__main__":
    main()

=========================================================================================================================================================================

#!pip install stegano
#P5 Steganography

from stegano import lsb

# Hide message in image
steg = lsb.hide('/content/flower.jpg', 'Flower is blue')
steg.save('/content/flower-secret.jpg')

# Retrieve hidden message
msg = lsb.reveal('D:/salma/flower-secret.png')
print(msg)


=========================================================================================================================================================================


#P6 HMAC

import hmac
import hashlib
import secrets

# Initial sent message
sent_msg = input("Enter message: ")
key = secrets.token_bytes(100)  # Secret key generation

# Generate HMAC for sent message
s_md_1 = hmac.new(key=key, msg=sent_msg.encode(), digestmod=hashlib.md5)
init_msg_digest = s_md_1.hexdigest()

# Simulate receiving the same message
received = sent_msg
r_md_1 = hmac.new(key=key, msg=received.encode(), digestmod=hashlib.md5)
recv_msg_digest = r_md_1.hexdigest()

# Comparing sent and received message digests
print("----- Before Tampering -----")
print("Is the message received without any tampering?:",
      hmac.compare_digest(init_msg_digest, recv_msg_digest))

# Simulate tampering the message
tampered_msg = sent_msg[1:]  # remove first character (just for testing tamper)
md_2 = hmac.new(key=key, msg=tampered_msg.encode(), digestmod=hashlib.md5)
tampered_msg_digest = md_2.hexdigest()

# Comparing tampered message digest with original
print("----- After Tampering -----")
print("Is the message received without any tampering?:",
      hmac.compare_digest(init_msg_digest, tampered_msg_digest))


=========================================================================================================================================================================

#P7A Elgamal_Algo

# Key & Cipher Generators
def generate_e2():
    e2 = pow(e1, d, p)
    return e2

def generate_c1():
    c1 = pow(e1, r, p)
    return c1

def generate_c2():
    c2 = (pt * pow(e2, r, p)) % p
    return c2

# Encryption Function
def encryption():
    ct = (c1, c2)
    return ct

# Decryption Function
def decryption():
    temp = pow(c1, d, p)  # temp = c1^d mod p
    temp_inv = None
    for i in range(1, p):
        if (temp * i) % p == 1:
            temp_inv = i
            break
    dpt = (c2 * temp_inv) % p
    return dpt

# User Input
p = int(input("Enter 1st part of public key (prime p): "))
e1 = int(input("Enter 2nd part of public key (primitive root e1): "))
d = int(input("Enter the private key d: "))
r = int(input("Enter a random integer r: "))
pt = int(input("Enter the plain text (number): "))

# Generation
e2 = generate_e2()
c1 = generate_c1()
c2 = generate_c2()

# Output
print("Encrypted Text:", encryption())
print("Decrypted Text:", decryption())


=========================================================================================================================================================================


#P7B Euclidean Algo

def gcd(a, b):
    temp = 0
    while True:
        temp = a % b
        if temp == 0:
            return b
        a = b
        b = temp

# User Input
a = int(input("Enter a value of a: "))
b = int(input("Enter a value of b: "))

# Output GCD
print("GCD of", a, ",", b, "is", gcd(a, b))

=========================================================================================================================================================================

#P8 RSA

import math

# GCD function using Euclidean Algorithm
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

# Prime numbers
p = 3
q = 7

# Calculate n and phi
n = p * q
phi = (p - 1) * (q - 1)

# Choose e such that 1 < e < phi and gcd(e, phi) = 1
e = 2
while e < phi:
    if gcd(e, phi) == 1:
        break
    else:
        e += 1

# Calculate d, the modular inverse of e
d = 0
for i in range(1, phi):
    if (e * i) % phi == 1:
        d = i
        break

# Message
msg = 12.0
print("Message data = ", msg)

# Encryption: c = (msg ^ e) % n
c = pow(int(msg), e, n)
print("Encrypted data = ", c)

# Decryption: m = (c ^ d) % n
m = pow(c, d, n)
print("Original Message Sent = ", m)